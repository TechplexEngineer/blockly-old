#!/usr/bin/perl
use strict;
use File::Slurp;

my $filename = shift or die;
my $contents = read_file($filename);

my @decls;
my %decls;
while ($contents =~ /interface\s+(\w+)(?:\s*:\s*([\s\w,]+))?\s*\{([^\}]*)\};/sg) {
    my($class, $deps, $members) = ($1, $2, $3);
    $deps = [split(/[\s,]+/, $deps)];
    $members = [grep(!/^$/, split(/\n/, $members))];
    my $decl = {class => $class, deps => $deps, members => $members};
    push(@decls, $decl);
    $decls{$class} = $decl;
}

use Data::Dumper;
#print Data::Dumper->Dumpxs([\@decls], [qw(decls)]);

print "/**\n * \@fileoverview Generated by $0 using $filename.\n";
print " * Please do not edit by hand.\n */\n";

foreach my $decl (@decls) {
    print "\n\n\n/**\n * ";
    printf("\@%s\n", constructorOrInterface($decl->{class}, $decl->{deps}));
    foreach my $dep (@{$decl->{deps}}) {
        printf(" * \@%s {%s}\n", extendsOrImplements($decl->{class}, $dep), $dep);
    }
    print " */\n";
    printf("function %s() {}\n", $decl->{class});

    printmembers($decl->{class}, $decl->{members});
    printdepsmembers($decl->{class}, $decl->{deps});
}

sub printdepsmembers {
    my($class, $deps) = @_;
    foreach my $dep (@$deps) {
        if (!isClass($dep)) {
            print "// Members of $dep\n";
            printmembers($class, $decls{$dep}->{members});
            printdepsmembers($class, $decls{$dep}->{deps});
        }
    }
}

sub printmembers {
    my($class, $members) = @_;
    foreach my $member (@$members) {
        printmember($class, $member);
    }
}

sub jstype {
    my $idltype = shift;
    if ($idltype =~ /\b(?:long|short|integer|int|float)\b/) {
        return 'number';
    }
    elsif ($idltype eq 'DOMString') {
        return 'string';
    }
    else {
        return $idltype;
    }
}

sub printattribute {
    my($class, $type, $name, $throw) = @_;
    warn "printattribute <$class>, <$type>, <$name>, <$throw>";
    printf("/** \@type {%s} */ %s.prototype.%s;\n", jstype($type), $class, $name);
}

sub printmethod {
    my($class, $ret, $name, $args, $throw) = @_;
    warn "printmethod <$class>, <$ret>, <$name>, <$args>, <$throw>\n";
    printf("\n/**\n");
    $args = [split(/,/, $args)];
    my @argnames;
    foreach my $arg (@$args) {
        if ($arg =~ /in\s+(.*)\s+(\w+)/) {
            push(@argnames, $2);
            printf(" * \@param {%s} %s\n", jstype($1), $2);
        }
    }
    if ($throw) {
        printf(" * \@throws {%s}\n", jstype($throw));
    }
    if ($ret ne 'void') {
        printf(" * \@return {%s}\n", jstype($ret));
    }
    print " */\n";
    printf("%s.prototype.%s = function(%s) {};\n", $class, $name,
           join(', ', @argnames));
}

sub printmember {
    my($class, $member) = @_;
    if ($member =~ /attribute\s+(.*?)\s+(\w+)(?:\s+setraises\((\w+)\))?;/) {
        printattribute($class, $1, $2, $3);
    }
    elsif ($member =~ /\s*(\w+)\s*(\w+)\(([^\)]*)\)(?:\s*raises\((\w+)\))?;/) {
        printmethod($class, $1, $2, $3, $4);
    }
    else {
        warn "$member doesn't match anything";
    }
}

sub isClass {
    my($class, $deps) = @_;

    ($class =~ /Element$/ ||
     $class !~ /^SVG/ ||
     grep(/Element$/, @$deps) ||
     grep(!/^SVG/, @$deps));
}

sub constructorOrInterface {
    my($class, $deps) = @_;
    isClass($class, $deps) ? 'constructor' : 'interface';
}

sub extendsOrImplements {
    my($class, $dep) = @_;
    (!isClass($class, []) || isClass($dep, [])) ? 'extends' : 'implements';
}
